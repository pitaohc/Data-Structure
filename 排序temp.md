# 第九章 排序

<!---toc--->
- [9.1 插入排序](./排序temp.md#91-插入排序)
- [9.2 希尔排序]
- [9.3 选择排序]
- [9.4 堆排序]
- [9.5 冒泡排序]
- [9.6 快速排序]
- [9.7 归并排序]
- [9.8 基数排序]
- [9.9 计数排序]
- [9.10 桶排序]
<!---/toc--->

## 9.1 插入排序
**思想**: 从无序部分选出一个数，插入到有序部分的正确位置  

**步骤**: 
1. 从无序部分选出一个数字
2. 从有序部分的最后一个数字开始比较，
直到位于正确的位置
3. 返回第一步

**稳定性**：稳定排序  
**时间复杂度**: O(n)至O(n2)，平均时间复杂度是O(n2)。  
**最好情况**：已经有序  
**最坏情况**：逆序 
``` c++
void insertSort(int arr[], int len)
{
	for (int i = 1; i < len; i++)
	{
		int key = arr[i]; //步骤1
		int j = i-1;
		while (arr[j]>key&&j>=0) //步骤2
		{
			arr[j + 1] = arr[j];
			j--;
		}
		if (j + 1 != i)
			arr[j + 1] = key;
	}
}
``` 

## 9.2 希尔排序
**思想**: Shell排序法是对相邻指定距离(称为增量)的元素进行比较，
并不断把增量缩小至1，完成排序。**插入排序是增量为1的希尔排序**  

**步骤**: 
Shell排序开始时增量较大，分组较多，每组的记录数目较少，
故在各组内采用直接插入排序较快，后来增量di逐渐缩小，分组数减少，
各组的记录数增多，但由于已经按di−1分组排序，文件叫接近于有序状态，
所以新的一趟排序过程较快。
因此Shell排序在效率上比直接插入排序有较大的改进。  
在直接插入排序的基础上，将直接插入排序中的1全部改变成增量d即可，
因为Shell排序最后一轮的增量d就为1。  
**稳定性**：不稳定排序  
**时间复杂度**: O(n1.3)到O(n2)。
影响因素：排序时增量的个数和取值。
若增量的取值比较合理，Shell的时间复杂度约为O(n1.3)。  
**最好情况**：O(n1.3)  
**最坏情况**：O(n2)  
```c++
void shellSort(int arrp, int len, int d = len / 2)
{
	for (int inc = d; inc >= 1; inc/=2)
	{
		for (int i = 1; i < len; i++)
		{
			int key = arr[i];
			int j = i - inc;
			while (j>=0&&arr[j]>key)
			{
				arr[j + inc] = arr[j];
				j -= inc;
			}
			if (j + inc != i)
				arr[j + inc] = key;
		}
	}
}
```
## 9.3 选择排序
**思想**: 从乱序部分选择最小的一个数，与乱序部分第一个元素交换  
**步骤**: 
1. 寻找最小数
2. 交换，重新执行 1

**稳定性**：不稳定排序  
**时间复杂度**: 最坏、最好和平均复杂度均为O(n2)  
**最好情况**：无  
**最坏情况**：无


## 9.4 堆排序
//to do  
**思想**: 利用堆化数组，详见[树](./树.md)-5.5  
**步骤**:   
**稳定性**：  
**时间复杂度**: O(N * logN)。  
由于每次重新恢复堆的时间复杂度为O(logN)，
共N - 1次堆调整操作，再加上前面建立堆时N / 2次向下调整，
每次调整时间复杂度也为O(logN)。两次次操作时间相加还是O(N * logN)。  
**最好情况**：逆序的  
**最坏情况**：有序的
## 9.5 冒泡排序

**思想**：  
从数组中第一个数开始，遍历全部数，相邻比较交换，
这样最大/最小的数就会随着冒泡过程逐渐移动到顶端

**步骤**：
1. 从数组中第一个数开始，依次与下一个数比较并次交换比自己小的数，
直到乱序部分最后的数。如果发生交换，则继续下面的步骤，如果未发生交换，
则数组有序，排序结束，此时时间复杂度为O(n)； 
2. 每一轮”冒泡”结束后，最大的数将出现在乱序数列的最后一位。
重复步骤 1。

**稳定性**: 稳定排序。  
**时间复杂度**: O(n)至O(n2)，平均时间复杂度为O(n2)。  
**最好情况**: 排序已完成  
**最坏情况**: 数组逆序  
``` c++
void bubbleSort(int arr[], int len)
{
	for (int i = 0; i < len - 1; ++i)
	{
		bool noSwapFlag = true;//完成排序标记
		for (int j = 0; j < len-i-1; ++j)
		{
			if (arr[j] > arr[j + 1])
			{
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
				noswapflag = false;
			}
		}
		if (noSwapFlag) return;
	}
}
```
## 9.6 快速排序
**思想**：分治思想  

**步骤**：
1. 从待排序的n个记录中任意选取一个记录(通常选取第一个记录)
为分区标准;

2. 把所有小于该排序列的记录移动到左边，
把所有大于该排序码的记录移动到右边，中间放所选记录，
称之为第一趟排序；

3. 然后对前后两个子序列分别重复上述过程，直到所有记录都排好序。

**稳定性**：不稳定  
**时间复杂度**：O(nlog2n)至O(n2)，平均时间复杂度为O(nlgn)  
**最好情况**：每趟排序后，分区长度大致相等  
**最坏情况**：待排序记录已经排好序  
``` c++
void quickSort(int arr[], int low, int high)
{
	int key = arr[0];
	int left = low, right = high;
	while (left<right)
	{
		while (left<right&&key<=arr[right])
		{
			--right;
		}
		arr[left] = arr[right];
		while (left < right && arr[left] <= key)
		{
			++left;
		}
		arr[right] = arr[left];
	}
	arr[left] = key;
	quickSort(arr, low, left - 1);
	quickSort(arr, left+1, high);
}
```
## 9.7 归并排序
**思想**: 将已有序的子序列合并，得到完全有序的序列；
即先使每个子序列有序，再使子序列段间有序。
若将两个有序表合并成一个有序表，称为二路归并。  
**步骤**:   
**稳定性**：稳定  
**时间复杂度**: Θ(nlgn)  
**最好情况**：无，Θ(nlgn)  
**最坏情况**：无，Θ(nlgn)  
## 9.8 基数排序
**思想**: 
**步骤**: 
**稳定性**：
**时间复杂度**: 
**最好情况**：
**最坏情况**：
## 9.9 计数排序
**思想**: 
**步骤**: 
**稳定性**：
**时间复杂度**: 
**最好情况**：
**最坏情况**：
## 9.10 桶排序
**思想**: 
**步骤**: 
**稳定性**：
**时间复杂度**: 
**最好情况**：
**最坏情况**：